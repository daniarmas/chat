package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"fmt"
	"net/http"
	"regexp"

	"github.com/daniarmas/chat/graph/model"
	"github.com/daniarmas/chat/internal/inputs"
	"github.com/daniarmas/chat/middleware"
	"github.com/google/uuid"
)

// SignIn is the resolver for the signIn field.
func (r *mutationResolver) SignIn(ctx context.Context, input model.SignInInput) (*model.SignInResponse, error) {
	var emailRegex = regexp.MustCompile("^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$")
	var validationErr = false
	var res model.SignInResponse
	var errorDetails []*model.ErrorDetails

	if input.Email == "" {
		errorDetails = append(errorDetails, &model.ErrorDetails{
			Field:   "email",
			Message: "This field is required",
		})
		validationErr = true
	}

	if input.Email != "" && !emailRegex.MatchString(input.Email) {
		errorDetails = append(errorDetails, &model.ErrorDetails{
			Field:   "email",
			Message: "This field is invalid",
		})
		validationErr = true
	}

	if input.Password == "" {
		errorDetails = append(errorDetails, &model.ErrorDetails{
			Field:   "password",
			Message: "This field is required",
		})
		validationErr = true
	}

	if validationErr {
		res.Message = "Bad request"
		res.Status = http.StatusBadRequest
		res.Data = nil
		res.Error = &model.Error{
			Code:    "INVALID_ARGUMENT",
			Message: "The request contains invalid arguments",
			Details: errorDetails,
		}
		return &res, nil
	}

	result, err := r.AuthUsecase.SignIn(ctx, inputs.SignInInput{Email: input.Email, Password: input.Password, Logout: input.Logout})
	if err != nil {
		switch err.Error() {
		case "the credentials are incorrect":
			res.Message = http.StatusText(http.StatusUnauthorized)
			res.Status = http.StatusUnauthorized
			res.Data = nil
			res.Error = &model.Error{
				Code:    "INVALID_CREDENTIALS",
				Message: "The credentials are incorrect.",
				Details: nil,
			}
			return &res, nil
		case "the user is already logged in":
			res.Message = http.StatusText(http.StatusConflict)
			res.Status = http.StatusConflict
			res.Data = nil
			res.Error = &model.Error{
				Code:    "USER_ALREADY_LOGGED_IN",
				Message: "The user is already logged in.",
				Details: nil,
			}
			return &res, nil
		default:
			res.Message = http.StatusText(http.StatusInternalServerError)
			res.Status = http.StatusInternalServerError
			res.Data = nil
			res.Error = &model.Error{
				Code:    "INTERNAL_SERVER_ERROR",
				Message: "The server has an internal error.",
				Details: nil,
			}
			return &res, nil
		}
	}

	res.Message = "Success"
	res.Status = http.StatusOK
	res.Data = &model.SignInData{
		Status: http.StatusOK,
		User: &model.User{
			ID:         result.User.ID.String(),
			Email:      result.User.Email,
			Fullname:   result.User.Fullname,
			Username:   result.User.Username,
			CreateTime: result.User.CreateTime,
		},
		AccessToken:  result.AccessToken,
		RefreshToken: result.RefreshToken,
	}

	return &res, nil
}

// SignOut is the resolver for the signOut field.
func (r *mutationResolver) SignOut(ctx context.Context) (*model.SignOutResponse, error) {
	var res model.SignOutResponse

	user := middleware.ForContext(ctx)
	if user == nil {
		res.Message = http.StatusText(http.StatusUnauthorized)
		res.Status = http.StatusUnauthorized
		res.Data = nil
		res.Error = &model.Error{
			Code:    "ACCESS_TOKEN_MISSING",
			Message: "This request requires an access token. Please provide a valid access token and try again.",
			Details: nil,
		}
		return &res, nil
	}

	err := r.AuthUsecase.SignOut(ctx, user.ID.String())
	if err != nil {
		switch err.Error() {
		default:
			res.Message = http.StatusText(http.StatusInternalServerError)
			res.Status = http.StatusInternalServerError
			res.Data = nil
			res.Error = &model.Error{
				Code:    "INTERNAL_SERVER_ERROR",
				Message: "The server has an internal error.",
				Details: nil,
			}
			return &res, nil
		}
	}

	res.Message = http.StatusText(http.StatusNoContent)
	res.Status = http.StatusNoContent
	res.Data = nil
	res.Error = nil
	return &res, nil
}

// SendMessage is the resolver for the sendMessage field.
func (r *mutationResolver) SendMessage(ctx context.Context, input model.SendMessageInput) (*model.SendMessageResponse, error) {
	var res model.SendMessageResponse
	var errorDetails []*model.ErrorDetails
	var validationErr = false
	var receiverId uuid.UUID

	user := middleware.ForContext(ctx)
	if user == nil {
		res.Message = http.StatusText(http.StatusUnauthorized)
		res.Status = http.StatusUnauthorized
		res.Data = nil
		res.Error = &model.Error{
			Code:    "ACCESS_TOKEN_MISSING",
			Message: "This request requires an access token. Please provide a valid access token and try again.",
			Details: nil,
		}
		return &res, nil
	}

	if input.Content == "" {
		errorDetails = append(errorDetails, &model.ErrorDetails{
			Field:   "content",
			Message: "This field is required",
		})
		validationErr = true
	}

	if input.ReceiverID == "" {
		errorDetails = append(errorDetails, &model.ErrorDetails{
			Field:   "receiver_id",
			Message: "This field is required",
		})
		validationErr = true
	} else {
		receiverId = uuid.MustParse(input.ReceiverID)
	}

	if validationErr {
		res.Message = "Bad request"
		res.Status = http.StatusBadRequest
		res.Data = nil
		res.Error = &model.Error{
			Code:    "INVALID_ARGUMENT",
			Message: "The request contains invalid arguments",
			Details: errorDetails,
		}
		return &res, nil
	}

	result, err := r.MessageUsecase.SendMessage(ctx, inputs.SendMessage{ReceiverID: &receiverId, Content: input.Content}, user.ID.String())
	if err != nil {
		switch err.Error() {
		default:
			res.Message = http.StatusText(http.StatusInternalServerError)
			res.Status = http.StatusInternalServerError
			res.Data = nil
			res.Error = &model.Error{
				Code:    "INTERNAL_SERVER_ERROR",
				Message: "The server has an internal error.",
				Details: nil,
			}
			return &res, nil
		}
	}

	res.Message = "Success"
	res.Status = http.StatusOK
	res.Data = &model.SendMessageData{
		Message: &model.Message{ID: result.ID.String(), Content: result.Content, SenderID: result.SenderID.String(), ReceiverID: result.ReceiverID.String(), CreateTime: result.CreateTime},
	}
	res.Error = nil

	return &res, nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.MeResponse, error) {
	var res model.MeResponse

	user := middleware.ForContext(ctx)
	if user == nil {
		res.Message = http.StatusText(http.StatusUnauthorized)
		res.Status = http.StatusUnauthorized
		res.Data = nil
		res.Error = &model.Error{
			Code:    "ACCESS_TOKEN_MISSING",
			Message: "This request requires an access token. Please provide a valid access token and try again.",
			Details: nil,
		}
		return &res, nil
	}

	result, err := r.AuthUsecase.Me(ctx, user.ID.String())
	if err != nil {
		switch err.Error() {
		default:
			res.Message = http.StatusText(http.StatusInternalServerError)
			res.Status = http.StatusInternalServerError
			res.Data = nil
			res.Error = &model.Error{
				Code:    "INTERNAL_SERVER_ERROR",
				Message: "The server has an internal error.",
				Details: nil,
			}
			return &res, nil
		}
	}

	res.Message = "Success"
	res.Status = http.StatusOK
	res.Data = &model.MeData{
		User: &model.User{ID: result.ID.String(), Email: result.Email, Fullname: result.Fullname, Username: result.Username, CreateTime: result.CreateTime},
	}
	res.Error = nil

	return &res, nil
}

// FetchMessages is the resolver for the fetchMessages field.
func (r *queryResolver) FetchMessages(ctx context.Context, input model.FetchAllMessagesInput) (*model.FetchMessagesResponse, error) {
	var res model.FetchMessagesResponse
	var messages []*model.Message

	user := middleware.ForContext(ctx)
	if user == nil {
		res.Message = http.StatusText(http.StatusUnauthorized)
		res.Status = http.StatusUnauthorized
		res.Data = nil
		res.Error = &model.Error{
			Code:    "ACCESS_TOKEN_MISSING",
			Message: "This request requires an access token. Please provide a valid access token and try again.",
			Details: nil,
		}
		return &res, nil
	}

	result, err := r.MessageUsecase.GetMessageByChat(ctx, inputs.GetMessagesByChat{ChatUserId: input.ChatUserID}, user.ID.String())
	if err != nil {
		switch err.Error() {
		default:
			res.Message = http.StatusText(http.StatusInternalServerError)
			res.Status = http.StatusInternalServerError
			res.Data = nil
			res.Error = &model.Error{
				Code:    "INTERNAL_SERVER_ERROR",
				Message: "The server has an internal error.",
				Details: nil,
			}
			return &res, nil
		}
	}

	for _, element := range result {
		messages = append(messages, &model.Message{
			ID:         element.ID.String(),
			Content:    element.Content,
			SenderID:   element.SenderID.String(),
			ReceiverID: element.ReceiverID.String(),
			CreateTime: element.CreateTime,
		})
	}

	res.Message = "Success"
	res.Status = http.StatusOK
	res.Data = &model.FetchAllMessagesData{
		Messages: messages,
	}
	res.Error = nil

	return &res, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	panic(fmt.Errorf("not implemented: Todos - todos"))
}
